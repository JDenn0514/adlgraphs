% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_dicho.R
\name{make_dicho}
\alias{make_dicho}
\title{Make dichotomous factors}
\usage{
make_dicho(x, flip_levels = FALSE)
}
\arguments{
\item{x}{A labelled vector or \code{factor}.}

\item{flip_levels}{Logical. If \code{FALSE}, the default, the factor levels are
kept the same. If \code{TRUE}, the factor levels are flipped. Only specify this
if you want to change the order of the factor level.}
}
\description{
Convert a vector of class \code{factor} or \code{numeric} with value labels (e.g.,
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}})
to a dichotomous factor vector. A dichotomous factor vector is a vector of
class \code{factor} with only two bipolar levels (e.g., "Agree" and "Disagree")
}
\details{
\code{make_dicho} was designed to work on any vector that is of class \code{factor},
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}},
or \code{numeric} with value labels. If the vector is  numeric with no value
labels, the function will return an error. This is because the function first
converts the vector to a factor using \code{make_factor()}. Then, it removes the
first word if there are multiple words in the factor level.

The resulting factor levels default to alphabetical but if you want to
reverse them, just set \code{flip_levels = TRUE} in the function.

In addition, this function adds two new attributes. The first attribute,
\code{transformation}, indicates the data transformation that the original vector
underwent to create this new vector. The second attribute, \code{label}, contains
the variable label that was found in the original variable. However, if the
original vector did not have a variable label, then this attribute will not
show up.
}
\examples{
# load the libraries
library(dplyr)
library(adlgraphs)

# Check a labelled variable -------------------------------------------------

# convert "top" into a dichotomous factor
new_df <- test_data \%>\%
  mutate(top_f2 = make_dicho(top)) \%>\%
  # keep only two relevant variables
  select(top, top_f2)

# compare "top" to "top_f2"
# we can see all response with "agree" in the name are now "agree" and
# all those with "disagree" are now "disagree"
new_df

# show the attributes
attributes(new_df$top_f2)

# Check a factor variable ---------------------------------------------------
new_df <- test_data \%>\%
  mutate(
    # convert it to a factor
    top_f = make_factor(top),
    # convert the dichotomous factor
    top_f2 = make_dicho(top_f)
  ) \%>\%
  # select the three variables to compare them
  select(top, top_f, top_f2)

# compare the three variables
new_df

# show the attributes for the new variable
attributes(new_df$top_f2)

# Show it with flipped levels -----------------------------------------------

# let's do the same thing but let's flip the levels now
new_df <- test_data \%>\%
  mutate(
    # show it without flipping the levels
    top_f2 = make_dicho(top),
    # show it with the levels being flipped
    top_f2_flip = make_dicho(top, flip_levels = TRUE)
  ) \%>\%
  # keep only relevant variables
  select(top, top_f2, top_f2_flip)

# compare them
new_df

# They look the same but if we check the levels of the factor we can see
# that they are in different orders
attributes(new_df$top_f2)
attributes(new_df$top_f2_flip)

# ----------------------------------------------------------------------------
# function also works inside dplyr::across()

# Create new columns using `across()`
new_df <- test_data \%>\%
  dplyr::mutate(
    # use this example if you don't want to flip the factor levels
    dplyr::across(
      c(top:deserving),
      make_dicho,
      .names = "{col}_f2"
    ),
    # if you want to flip the factor levels, follow this example
    dplyr::across(
      c(top:deserving),
      ~make_dicho(., flip_levels = TRUE),
      .names = "{col}_f2_flip"
    )
  ) \%>\%
  # select the variables with "f2" in the name
  select(contains("f2"))

# show that the function worked properly by creating two new sets of variables
new_df

# show the underlying structure of the entire df
str(new_df)

# show how the levels are flipped when "flip_levels = TRUE"
levels(new_df$top_f2)
levels(new_df$top_f2_flip)


}
