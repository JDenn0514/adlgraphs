% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_dicho.R
\name{make_dicho}
\alias{make_dicho}
\title{Make dichotomous factors}
\usage{
make_dicho(x, flip_levels = FALSE)
}
\arguments{
\item{x}{A vector of type \code{haven_labelled} or \code{factor}.}

\item{flip_levels}{Logical. If \code{FALSE}, the default, the factor levels are
kept the same. If \code{TRUE}, the factor levels are flipped. Only specify this
if you want to change the order of the factor level.}
}
\description{
Convert a vector of class \code{factor} or
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}}
to a "dichotomous factor vector". When I refer to a "dichotomous factor
vector", I am referring to a vector of class \code{factor} with only two levels
that are opposites (e.g., "Agree" and "Disagree")
}
\details{
\code{make_dicho} was designed to work on any vector that is of class \code{factor},
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}},
or \code{numeric} with value labels. If the vector is  numeric with no value
labels, the function will return an error. This is because the function first
converts the vector to a factor using \code{\link[=as_factor]{as_factor()}} \code{\link[haven:as_factor]{haven::as_factor()}}
from the \code{haven} package. Then, it removes the first word if there are
multiple words in the factor level.

The resulting factor levels default to alphabetical but if you want to
reverse them, just set \code{flip_levels = TRUE} in the function.

In addition, this function adds two new attributes. The first attribute,
\code{transformation}, indicates the data transformation that the original vector
underwent to create this new vector. The second attribute, \code{label}, contains
the variable label that was found in the original variable. However, if the
original vector did not have a variable label, then this attribute will not
show up. This is only useful if you care about
}
\examples{
library(tibble)
library(dplyr)
library(labelled)
library(haven)

# create fake data
df <- tibble::tribble(
  ~x, ~y, ~z,
  3, 2, 3,
  4, 4, 2,
  2, 6, 1,
  1, 1, 4,
  5, 4, 3,
  6, 5, 6
) \%>\%
# add value labels
labelled::set_value_labels(
  x = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6),
  y = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6),
  z = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6)
) \%>\%
# add variable labels
labelled::set_variable_labels(
  x = "This is the variable label for x",
  y = "This is the variable label for y",
  z = "This is the variable label for z"
)

# show the data transformation with a haven_labelled vector
dicho_df <- df \%>\% dplyr::mutate(dicho_x = make_dicho(x))
# check the updated dataset
dicho_df

# Check the attributes
attributes(dicho_df$dicho_x)
# another way of checking the attributes
str(dicho_df$dicho_x)

# check the factor levels
unique(dicho_df$dicho_x)

# ----------------------------------------------------------------------------

# function also works with factors
dicho_df <- df \%>\%
  dplyr::mutate(
    # convert variable to a factor
    factor_x = haven::as_factor(x),
    # convert the factor to a dichotomous factor
    dicho_x = make_dicho(factor_x)
  )

# check the updated dataset
dicho_df

# Check the attributes
attributes(dicho_df$dicho_x)
# another way of checking the attributes
str(dicho_df$dicho_x)

# check the factor levels
unique(dicho_df$dicho_x)

# ----------------------------------------------------------------------------
# function also works inside dplyr::across()

# Create new columns using `across()`
dicho_df <- df \%>\%
  dplyr::mutate(
    # use this example if you don't want to flip the factor levels
    dplyr::across(
      x:z,
      make_dicho,
      .names = "dicho_{col}"
    ),
    # if you want to flip the factor levels, follow this example
    dplyr::across(
      x:z,
      ~make_dicho(., flip_levels = TRUE),
      .names = "dicho_flipped_{col}"
    )
  )
# show that the function worked properly by creating two new sets of variables
dicho_df

# show the underlying structure of the entire df
str(dicho_df)

# show how the levels are flipped when "flip_levels = TRUE"
levels(dicho_df$dicho_x)
levels(dicho_df$dicho_flipped_x)


}
