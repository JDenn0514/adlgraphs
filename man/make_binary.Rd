% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_binary.R
\name{make_binary}
\alias{make_binary}
\title{Make binary variables}
\usage{
make_binary(x, flip_values = FALSE)
}
\arguments{
\item{x}{A vector of class \code{haven_labelled} or \code{factor}.}

\item{flip_values}{Logical. If \code{FALSE}, the default, the values are kept the
same. If \code{TRUE}, the values associated with 1 and 0 are flipped. See third
example for more information.}
}
\description{
Convert a vector of class \code{factor} or
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}}
to a "binary vector". When I refer to a "binary vector", I am referring to a
vector of class \code{numeric} with two values: 0 or 1. Another way of thinking
about this is by turning a variable into a dummy variable.
}
\details{
\code{make_binary()} builds off \code{\link[=make_dicho]{make_dicho()}} and therefore was designed to work
on any vector that is of class \code{factor},
\href{https://haven.tidyverse.org/reference/labelled.html}{\code{haven_labelled}},
or \code{numeric} with value labels. Because this was built off of \link{make_dicho},
if the vector is  numeric with no value labels, the function will return an
error.

Similar to how \code{\link[=make_dicho]{make_dicho()}} provides the opportunity to flip the factor
levels, \code{make_binary()} allows you to flip which values should be recoded as
0 and which should be recoded as 1. To do so, just set \code{flip_values = TRUE}.

In addition, this function adds three new attributes. The first attribute,
\code{transformation}, indicates the data transformation that the original vector
underwent to create this new vector. The second attribute, \code{label}, contains
the variable label that was found in the original variable. However, if the
original vector did not have a variable label, then this attribute will not
show up. The third attribute, \code{labels}, adds value labels so you can see
what the 1 and 0 mean.
}
\examples{
library(tibble)
library(dplyr)
library(labelled)
library(haven)

# create fake data
df <- tibble::tribble(
  ~x, ~y, ~z,
  3, 2, 3,
  4, 4, 2,
  2, 6, 1,
  1, 1, 4,
  5, 4, 3,
  6, 5, 6
) \%>\%
# add value labels
labelled::set_value_labels(
  x = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6),
  y = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6),
  z = c(`Strongly agree` = 1,
        `Agree` = 2,
        `Somewhat agree` = 3,
        `Somewhat disagree` = 4,
        `Disagree` = 5,
        `Strongly disagree` = 6)
) \%>\%
# add variable labels
labelled::set_variable_labels(
  x = "This is the variable label for x",
  y = "This is the variable label for y",
  z = "This is the variable label for z"
)

# show the data transformation with a haven_labelled vector
binary_df <- df \%>\% dplyr::mutate(binary_x = make_binary(x))
# check the updated dataset
binary_df

# Check the attributes
attributes(binary_df$binary_x)
# another way of checking the attributes
str(binary_df$binary_x)

# check the factor levels
unique(binary_df$binary_x)

# ----------------------------------------------------------------------------

# function also works with factors
binary_df <- df \%>\%
  dplyr::mutate(
    # convert variable to a factor
    factor_x = make_factor(x),
    # convert the factor to a binary variable
    binary_x = make_binary(factor_x)
  )

# check the updated dataset
binary_df

# Check the attributes
attributes(binary_df$binary_x)
# another way of checking the attributes
str(binary_df$binary_x)

# check the factor levels
unique(binary_df$binary_x)

# ----------------------------------------------------------------------------

# function also works inside dplyr::across()

# Create new columns using `across()`
binary_df <- df \%>\%
  dplyr::mutate(
    # use this example if you don't want to flip the factor levels
    dplyr::across(
      x:z,
      make_binary,
      .names = "binary_{col}"
    ),
    # if you want to flip the factor levels, follow this example
    dplyr::across(
      x:z,
      ~make_binary(., flip_values = TRUE),
      .names = "binary_flipped_{col}"
    )
  )
# show that the function worked properly by creating two new sets of variables
binary_df

# show the underlying structure of the entire df
str(binary_df)

# show how the levels are flipped when "flip_levels = TRUE"
levels(binary_df$binary_x)
levels(binary_df$binary_flipped_x)

}
